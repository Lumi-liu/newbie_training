linux 設備驅動的練習
第一個驅動的練習是關於 hello word 的顯示,熟悉簡單的驅動開發和最重
要的組成模組,剛開始我只是看著書上面的知識點進行瞭解以及程式的編寫,後來
在部門主管的提問下,我瞬間變得好無知,各個函數中有幾種參數和其中參數的
含義及用法,聽了這些我明白,我們不管做什麼事情,在明白是什麼的同時也在
心裡一定要有為什麼這樣的疑問。
在接下來的練習中主要是針對字元型設備驅動的訓練,之前我也有接觸到
類似程序的編寫,不過當時不是我一個人獨立完成的,而現在要讓我獨自一個人
去做確實是第一次,從巨集定義結構體的記憶體以及類的定義,到 file_operations
結構體中的成員函數 open(),ioctl(),read(),write(),release()
等等,之後就是在驅動程式中扮演著兩個重要角色的函數了,驅動程式的載入
函數和程式的卸載函數。
在這些函數的編寫中我也曾遇到過很多的問題,每個設備都會對應的有個
設備號,設備號是一個 32 位的二進位數字,高 12 位元是主設備號,低 20 位元
是次設備號,主設備號識別設備對應的驅動程式,當設備打開(open)時,內核
利用主設備號分派執行相應的驅動程式。次設備號只由相應的設備驅動程式使用,
內核的其他部分不使用它,僅將它傳遞給驅動程式,次序號提供了一種區分它們
的方法。在 2.6 以後的版本內核中去掉了 ioctl()這個成員函數,新增了
unlocked_ioctl()和 compat_ioctl()兩個成員函數,而且把以前版本
中的 int 整型改成了 long 長整型。
另外還有在驅動程式的卸載函數中同樣也遇到了問題,程式能正確編譯運
行,但是在插入模組的時候不能二次插入,二次插入的時候會提示錯誤,只有在
電腦重啟的情況下才能再一次插入,這個問題讓我糾結了很長時間,最後在我查
找書籍又結合著網上的以下資料,這個問題才得以解決。在接下來的混雜型驅動
程式中,在查看了相關的書籍之後,按照書上面的給定的方法就可以完成了,普
通的字元驅動程式完成初始化的順序如下。
1,通過 alloc_chrdev_region()及相關函數分配主/次設備號。
2,使用 device_create()創建/dev 和/sys 節點。
3,使用 cdev_init()和 cdev_add()將自身註冊為字元驅動程式。
混雜驅動只需要調用 misc_register()即可完成字元驅動的所有步驟:
static struct misdevice mydrv_dev={
MYDRV_MINOR,
"mydrv",
&mydrv_fops
};
misc_register(&mydrv_dev);
